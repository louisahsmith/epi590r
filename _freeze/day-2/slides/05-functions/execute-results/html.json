{
  "hash": "a8b91a8453d30c646a5036d3fa285538",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\nformat: revealjs\nexecute: \n  eval: true\n  echo: true\n---\n\n\n## Functions in R\n\nI've been denoting functions with parentheses: `func()`\n\nWe've seen functions such as:\n\n-   `mean()`\n-   `tbl_summary()`\n-   `init()`\n-   `create_github_token`\n\nFunctions take **arguments** and return **values**\n\n## Looking inside a function\n\nIf you want to see the code within a function, you can just type its name without the parentheses:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_github_token\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (scopes = c(\"repo\", \"user\", \"gist\", \"workflow\"), description = \"DESCRIBE THE TOKEN'S USE CASE\", \n    host = NULL) \n{\n    scopes <- glue_collapse(scopes, \",\")\n    host <- get_hosturl(host %||% default_api_url())\n    url <- glue(\"{host}/settings/tokens/new?scopes={scopes}&description={description}\")\n    withr::defer(view_url(url))\n    hint <- code_hint_with_host(\"gitcreds::gitcreds_set\", host)\n    message <- c(`_` = \"Call {.run {hint}} to register this token in the local Git\\n           credential store.\")\n    if (is_linux()) {\n        message <- c(message, `!` = \"On Linux, it can be tricky to store credentials persistently.\", \n            i = \"Read more in the {.href ['Managing Git(Hub) Credentials' article](https://usethis.r-lib.org/articles/articles/git-credentials.html)}.\")\n    }\n    message <- c(message, i = \"It is also a great idea to store this token in any\\n           password-management software that you use.\")\n    ui_bullets(message)\n    invisible()\n}\n<bytecode: 0x141ac26a0>\n<environment: namespace:usethis>\n```\n\n\n:::\n:::\n\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function()\n```\n:::\n\n\nYou can name your function like you do any other object\n\n-   Just avoid names of existing functions\n\n\n## Structure of a function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val)\n}\n```\n:::\n\n\nWhat objects/values do you need to make your function work?\n\n-   You can give them default values to use if the user doesn't specify others\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val) {\n\n} \n```\n:::\n\n\nEverything else goes within curly braces\n\n-   Code in here will essentially look like any other R code, using any inputs to your functions\n\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val) {\n  new_val <- # do something with args \n} \n```\n:::\n\n\n-   One thing you'll likely want to do is make new objects along the way\n\n-   These aren't saved to your environment (i.e., you won't see them in the upper-right window) when you run the function\n\n-   You can think of them as being stored in a temporary environment within the function\n\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val) {\n  new_val <- # do something with args\n  return(new_val)\n} \n```\n:::\n\n\nReturn something new that the code has produced\n\n-   The `return()` statement is actually optional. If you don't put it, it will return the last object in the code. When you're starting out, it's safer to always explicitly write out what you want to return.\n\n\n## Example: a new function for the mean\n\nLet's say we are not satisfied with the `mean()` function and want to write our own.\n\nHere's the general structure we'll start with.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean <- function() {\n\n}\n```\n:::\n\n:::\n\n## New mean: arguments\n\nWe'll want to take the mean of a vector of numbers.\n\nIt will help to make an example of such a vector to think about what the input might look like, and to test the function. We'll call it `x`:\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 3, 5, 7, 9)\n```\n:::\n\n:::\n\nWe can add `x` as an argument to our function:\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean <- function(x) {\n\n}\n```\n:::\n\n:::\n\n## New mean: function body\n\nLet's think about how we calculate a mean in math, and then translate it into code:\n\n$$\\bar{x} = \\frac{1}{n}\\sum_{i = 1}^n x_i$$\n\nSo we need to sum the elements of `x` together, and then divide by the number of elements.\n\n## \n\nWe can use the functions `sum()` and `length()` to help us.\n\nWe'll write the code with our test vector first, before inserting it into the function:\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- length(x)\nsum(x) / n\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n:::\n\n## New mean: function body\n\nOur code seems to be doing what we want, so let's insert it. To be explicit, I've stored the answer (within the function) as `mean_val`, then returned that value.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean <- function(x) {\n  n <- length(x)\n  mean_val <- sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n:::\n\n## Testing a function\n\nLet's plug in the vector that we created to test it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean(x = x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\nAnd then try another one we create on the spot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean(x = c(100, 200, 300))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 200\n```\n\n\n:::\n:::\n\n\n## Exercises\n\nCreate some functions!\n\nCreate an R script in your project called `functions.R` to save your work!",
    "supporting": [
      "05-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}