{
  "hash": "af07de384fab44cec7e716d063c81faa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions, continued\"\nformat: revealjs\nexecute: \n  eval: true\n  echo: true\n---\n\n\n\n## Adding another argument\n\nLet's say we plan to be using our `new_mean()` function to calculate proportions (i.e., the mean of a binary variable). Sometimes we'll want to report them as as percentage by multiplying the proportion by 100.\n\nLet's name our new function `prop()`. We'll use the same structure as we did with `new_mean()`.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- function(x) {\n  n <- length(x)\n  mean_val <- sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n:::\n\n## Testing the code\n\nNow we'll want to test on a vector of 1's and 0's.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, 1, 1)\n```\n:::\n\n:::\n\nTo calculate the proportion and turn it into a percentage, we'll just multiply the mean by 100.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplier <- 100\nmultiplier * sum(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 66.66667\n```\n\n\n:::\n:::\n\n:::\n\n## Testing the code\n\nWe want to give users the option to choose between a proportion and a percentage. So we'll add an argument `multiplier`. When we want to just return the proportion, we can just set `multiplier` to be 1.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplier <- 1\nmultiplier * sum(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6666667\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplier <- 100\nmultiplier * sum(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 66.66667\n```\n\n\n:::\n:::\n\n:::\n\n## Adding another argument\n\nIf we add `multiplier` as an argument, we can refer to it in the function body.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- function(x, multiplier) {\n  n <- length(x)\n  mean_val <- multiplier * sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n:::\n\n## Adding another argument\n\nNow we can test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(1, 0, 1, 0), multiplier = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(1, 0, 1, 0), multiplier = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50\n```\n\n\n:::\n:::\n\n\n\n## Making a default argument\n\nSince we don't want users to have to specify `multiplier = 1` every time they just want a proportion, we can set it as a **default**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- function(x, multiplier = 1) {\n  n <- length(x)\n  mean_val <- multiplier * sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n\nNow we only need to specify that argument if we want a percentage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(0, 1, 1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.75\n```\n\n\n:::\n\n```{.r .cell-code}\nprop(x = c(0, 1, 1, 1), multiplier = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 75\n```\n\n\n:::\n:::\n\n\n## Caveats\n\n-   This is obviously not the best way to write this function!\n\n-   For example, it will still work if `x = c(123, 593, -192)`.... but it certainly won't give you a proportion or a percentage!\n\n-   We could also put `multiplier =` *any number*, and we'll just be multiplying the answer by that number -- this is essentially meaningless.\n\n-   We also haven't done any checking to see whether the user is even entering numbers! We could put in better error messages so users don't just get an R default error message if they do something wrong.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(\"blah\", \"blah\", \"blah\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sum(x): invalid 'type' (character) of argument\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}